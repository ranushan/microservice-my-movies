"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const bindEndpointMiddleware_1 = require("../middlewares/bindEndpointMiddleware");
const SendResponseMiddleware_1 = require("../middlewares/SendResponseMiddleware");
const statusAndHeadersMiddleware_1 = require("../middlewares/statusAndHeadersMiddleware");
const PlatformRouter_1 = require("../services/PlatformRouter");
class ControllerBuilder {
    constructor(provider) {
        this.provider = provider;
    }
    /**
     *
     * @returns {any}
     */
    build(injector) {
        const { routerOptions, middlewares: { useBefore, useAfter } } = this.provider;
        this.provider.router = PlatformRouter_1.PlatformRouter.create(injector, routerOptions);
        // Controller lifecycle
        this.buildMiddlewares(useBefore) // Controller before-middleware
            .buildEndpoints() // All endpoints and his middlewares
            .buildMiddlewares(useAfter) // Controller after-middleware
            .buildChildrenCtrls(injector); // Children controllers
        return this.provider.router;
    }
    buildEndpoints() {
        const { endpoints } = this.provider;
        const pathsMethodsMap = new Map();
        const getKey = (method, path) => `${method}-${path}`;
        const updateFinalRouteState = (key) => {
            if (pathsMethodsMap.has(key)) {
                pathsMethodsMap.get(key).isFinal = false;
            }
        };
        const setFinalRoute = (key, pathMethod) => {
            pathsMethodsMap.set(key, pathMethod);
            pathMethod.isFinal = true;
        };
        endpoints.forEach(({ pathsMethods }) => {
            pathsMethods.forEach(pathMethod => {
                pathMethod.method = pathMethod.method || "use";
                if (pathMethod.method !== "use") {
                    const key = getKey(pathMethod.method, pathMethod.path);
                    updateFinalRouteState(key);
                    updateFinalRouteState(getKey("all", pathMethod.path));
                    setFinalRoute(key, pathMethod);
                }
            });
        });
        endpoints.forEach(endpoint => {
            this.buildEndpoint(endpoint);
        });
        return this;
    }
    buildEndpoint(endpoint) {
        const { beforeMiddlewares, middlewares: mldwrs, afterMiddlewares, pathsMethods } = endpoint;
        const { router, middlewares: { use } } = this.provider;
        // Endpoint lifecycle
        let handlers = [];
        handlers = handlers
            .concat(bindEndpointMiddleware_1.bindEndpointMiddleware(endpoint))
            .concat(use) // Controller use-middlewares
            .concat(beforeMiddlewares) // Endpoint before-middlewares
            .concat(mldwrs) // Endpoint middlewares
            .concat(endpoint) // Endpoint metadata
            .concat(statusAndHeadersMiddleware_1.statusAndHeadersMiddleware)
            .concat(afterMiddlewares) // Endpoint after-middlewares
            .filter((item) => !!item);
        // Add handlers to the router
        pathsMethods.forEach(({ path, method, isFinal }) => {
            const localHandlers = isFinal ? handlers.concat(SendResponseMiddleware_1.SendResponseMiddleware) : handlers;
            router.addRoute({ method: method, path, handlers: localHandlers });
        });
        if (!pathsMethods.length) {
            router.use(...handlers);
        }
    }
    buildChildrenCtrls(injector) {
        const { children, router } = this.provider;
        children.forEach((child) => {
            const provider = injector.getProvider(child);
            /* istanbul ignore next */
            if (!provider) {
                throw new Error("Controller component not found in the ControllerRegistry");
            }
            new ControllerBuilder(provider).build(injector);
            router.use(provider.path, provider.router);
        });
    }
    buildMiddlewares(middlewares) {
        const { router } = this.provider;
        middlewares
            .filter(o => typeof o === "function")
            .forEach((middleware) => {
            router.use(middleware);
        });
        return this;
    }
}
exports.ControllerBuilder = ControllerBuilder;
//# sourceMappingURL=ControllerBuilder.js.map