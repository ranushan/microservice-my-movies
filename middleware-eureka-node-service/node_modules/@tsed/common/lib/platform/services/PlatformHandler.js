"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const di_1 = require("@tsed/di");
const mvc_1 = require("../../mvc");
const ValidationError_1 = require("../../mvc/errors/ValidationError");
const HandlerContext_1 = require("../domain/HandlerContext");
const ParamValidationError_1 = require("../errors/ParamValidationError");
const UnknownFilterError_1 = require("../errors/UnknownFilterError");
let PlatformHandler = class PlatformHandler {
    constructor(injector) {
        this.injector = injector;
    }
    createHandlerMetadata(obj) {
        const { injector } = this;
        let options;
        if (obj instanceof mvc_1.EndpointMetadata) {
            const provider = injector.getProvider(obj.target);
            options = {
                token: provider.provide,
                target: provider.useClass,
                type: mvc_1.HandlerType.CONTROLLER,
                propertyKey: obj.propertyKey
            };
        }
        else {
            const provider = injector.getProvider(obj);
            if (provider) {
                options = {
                    token: provider.provide,
                    target: provider.useClass,
                    type: mvc_1.HandlerType.MIDDLEWARE,
                    propertyKey: "use"
                };
            }
            else {
                options = {
                    target: obj,
                    type: mvc_1.HandlerType.FUNCTION
                };
            }
        }
        return new mvc_1.HandlerMetadata(options);
    }
    /**
     * Create a native middleware based on the given metadata and return an instance of HandlerContext
     * @param metadata
     */
    createHandler(metadata) {
        if (!(metadata instanceof mvc_1.HandlerMetadata)) {
            metadata = this.createHandlerMetadata(metadata);
        }
        if (metadata.type === mvc_1.HandlerType.FUNCTION) {
            return metadata.handler;
        }
        this.sortPipes(metadata);
        return this.createRawHandler(metadata);
    }
    /**
     * Get param from the context
     * @param param
     * @param context
     */
    getParam(param, context) {
        switch (param.paramType) {
            case mvc_1.ParamTypes.FORM_DATA:
                return context.request;
            case mvc_1.ParamTypes.BODY:
                return context.request.body;
            case mvc_1.ParamTypes.QUERY:
                return context.request.query;
            case mvc_1.ParamTypes.PATH:
                return context.request.params;
            case mvc_1.ParamTypes.HEADER:
                return context.request.headers;
            case mvc_1.ParamTypes.COOKIES:
                return context.request.cookies;
            case mvc_1.ParamTypes.SESSION:
                return context.request.session;
            case mvc_1.ParamTypes.LOCALS:
                return context.response.locals;
            case mvc_1.ParamTypes.RESPONSE:
                return context.response;
            case mvc_1.ParamTypes.REQUEST:
                return context.request;
            case mvc_1.ParamTypes.NEXT_FN:
                return context.next;
            case mvc_1.ParamTypes.ERR:
                return context.err;
            case mvc_1.ParamTypes.CONTEXT:
                return context.request.ctx;
            case mvc_1.ParamTypes.ENDPOINT_INFO:
                return context.request.ctx.endpoint;
            case mvc_1.ParamTypes.RESPONSE_DATA:
                return context.request.ctx.data;
            default:
                if (param.filter) {
                    return this.getFilter(param, context);
                }
                return context.request;
        }
    }
    /**
     * Return a custom filter
     * @param param
     * @param context
     * @deprecated
     */
    getFilter(param, context) {
        const { expression } = param;
        const instance = this.injector.get(param.filter);
        if (!instance || !instance.transform) {
            throw new UnknownFilterError_1.UnknownFilterError(param.filter);
        }
        return instance.transform(expression, context.request, context.response);
    }
    createRawHandler(metadata) {
        if (metadata.hasErrorParam) {
            return (err, request, response, next) => this.onRequest(new HandlerContext_1.HandlerContext({
                injector: this.injector,
                request,
                response,
                next,
                err,
                metadata,
                args: []
            }));
        }
        else {
            return (request, response, next) => this.onRequest(new HandlerContext_1.HandlerContext({
                injector: this.injector,
                request,
                response,
                next,
                metadata,
                args: []
            }));
        }
    }
    onRequest(context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            if (context.isDone) {
                return;
            }
            const { metadata: { parameters } } = context;
            try {
                context.args = yield Promise.all(parameters.map(param => this.mapParam(param, context)));
                yield context.callHandler();
            }
            catch (error) {
                context.next(error);
            }
        });
    }
    sortPipes(metadata) {
        const get = (pipe) => {
            return this.injector.getProvider(pipe).priority || 0;
        };
        metadata.parameters.forEach((param) => {
            return (param.pipes = param.pipes.sort((p1, p2) => {
                return get(p1) < get(p2) ? -1 : get(p1) > get(p2) ? 1 : 0;
            }));
        });
    }
    /**
     *
     * @param metadata
     * @param context
     */
    mapParam(metadata, context) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { injector } = context;
            const value = this.getParam(metadata, context);
            // istanbul ignore next
            const handleError = (cb) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                try {
                    return yield cb();
                }
                catch (er) {
                    throw er instanceof ValidationError_1.ValidationError ? ParamValidationError_1.ParamValidationError.from(metadata, er) : er;
                }
            });
            return metadata.pipes.reduce((value, pipe) => tslib_1.__awaiter(this, void 0, void 0, function* () {
                value = yield value;
                return handleError(() => injector.get(pipe).transform(value, metadata));
            }), value);
        });
    }
};
PlatformHandler = tslib_1.__decorate([
    di_1.Injectable({
        scope: di_1.ProviderScope.SINGLETON
    }),
    tslib_1.__metadata("design:paramtypes", [di_1.InjectorService])
], PlatformHandler);
exports.PlatformHandler = PlatformHandler;
//# sourceMappingURL=PlatformHandler.js.map