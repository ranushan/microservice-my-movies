"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const di_1 = require("@tsed/di");
const ControllerBuilder_1 = require("../builder/ControllerBuilder");
const PlatformApplication_1 = require("./PlatformApplication");
const PlatformHandler_1 = require("./PlatformHandler");
const PlatformRouter_1 = require("./PlatformRouter");
/**
 * `Platform` is used to provide all routes collected by annotation `@Controller`.
 */
let Platform = class Platform {
    constructor(injector, platformApplication, platformHandler) {
        this.injector = injector;
        this.platformApplication = platformApplication;
        this.platformHandler = platformHandler;
        this._routes = [];
    }
    get app() {
        return this.platformApplication;
    }
    get routes() {
        return this._routes || [];
    }
    /**
     * Create a native metadata base on the metadata or to the given Class.
     * @param handler
     */
    createHandler(handler) {
        return this.platformHandler.createHandler(handler);
    }
    /**
     * Create routers from the collected controllers
     */
    createRoutersFromControllers() {
        const { injector } = this;
        return injector
            .getProviders(di_1.ProviderType.CONTROLLER)
            .map(provider => {
            if (!provider.hasParent()) {
                return new ControllerBuilder_1.ControllerBuilder(provider).build(injector);
            }
        })
            .filter(Boolean);
    }
    /**
     * Create a new instance of PlatformRouter
     * @param routerOptions
     */
    createRouter(routerOptions = {}) {
        return PlatformRouter_1.PlatformRouter.create(this.injector, routerOptions);
    }
    addRoutes(routes) {
        routes.forEach(routeSettings => {
            this.addRoute(routeSettings.route, routeSettings.token);
        });
    }
    addRoute(endpoint, token) {
        const { injector } = this;
        if (injector.hasProvider(token)) {
            const provider = injector.getProvider(token);
            if (provider.type === di_1.ProviderType.CONTROLLER) {
                const route = provider.getEndpointUrl(endpoint);
                if (!provider.hasParent()) {
                    this._routes.push({
                        route,
                        provider
                    });
                    this.app.use(route, provider.router.callback());
                }
            }
        }
        return this;
    }
    /**
     * Get all routes built by TsExpressDecorators and mounted on Express application.
     * @returns {IRouteDetails[]}
     */
    getRoutes() {
        let routes = [];
        this.routes.forEach((config) => {
            routes = routes.concat(this.buildRoutes(config.route, config.provider));
        });
        return routes;
    }
    /**
     *
     * @param ctrl
     * @param endpointUrl
     */
    buildRoutes(endpointUrl, ctrl) {
        const { injector } = this;
        let routes = [];
        ctrl.children
            .map(ctrl => injector.getProvider(ctrl))
            .forEach((provider) => {
            routes = routes.concat(this.buildRoutes(`${endpointUrl}${provider.path}`, provider));
        });
        ctrl.endpoints.forEach((endpoint) => {
            const { pathsMethods, params, targetName, propertyKey } = endpoint;
            pathsMethods.forEach(({ path, method }) => {
                if (!!method) {
                    routes.push({
                        method,
                        name: `${targetName}.${String(propertyKey)}()`,
                        url: `${endpointUrl}${path || ""}`.replace(/\/\//gi, "/"),
                        className: targetName,
                        methodClassName: String(propertyKey),
                        parameters: params
                    });
                }
            });
        });
        return routes;
    }
};
Platform = tslib_1.__decorate([
    di_1.Injectable({
        scope: di_1.ProviderScope.SINGLETON
    }),
    tslib_1.__metadata("design:paramtypes", [di_1.InjectorService,
        PlatformApplication_1.PlatformApplication,
        PlatformHandler_1.PlatformHandler])
], Platform);
exports.Platform = Platform;
//# sourceMappingURL=Platform.js.map