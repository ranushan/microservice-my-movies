"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const platform_1 = require("../../platform");
const ContextMiddleware_1 = require("../middlewares/ContextMiddleware");
const utils_1 = require("../utils");
class PlatformBuilder {
    constructor() {
        this.startedAt = new Date();
    }
    get injector() {
        return this._injector;
    }
    get rootModule() {
        return this._rootModule;
    }
    get app() {
        return this.injector.get(platform_1.PlatformApplication);
    }
    get platform() {
        return this.injector.get(platform_1.Platform);
    }
    /**
     * Return the settings configured by the decorator @@ServerSettings@@.
     *
     * ```typescript
     * @ServerSettings({
     *    rootDir: Path.resolve(__dirname),
     *    port: 8000,
     *    httpsPort: 8080,
     *    mount: {
     *      "/rest": "${rootDir}/controllers/**\/*.js"
     *    }
     * })
     * export class Server extends ServerLoader {
     *     $onInit(){
     *         console.log(this.settings); // {rootDir, port, httpsPort,...}
     *     }
     * }
     * ```
     *
     * @returns {ServerSettingsService}
     */
    get settings() {
        return this.injector.settings;
    }
    get logger() {
        return this.injector.logger;
    }
    static build(platformBuildClass) {
        return new platformBuildClass();
    }
    /**
     * Add classes to the components list
     * @param classes
     */
    addComponents(classes) {
        this.settings.componentsScan = this.settings.componentsScan.concat(classes);
        return this;
    }
    /**
     * Add classes decorated by @@Controller()@@ to components container.
     *
     * ### Example
     *
     * ```typescript
     * @Controller('/ctrl')
     * class MyController{
     * }
     *
     * new ServerLoader().addControllers('/rest', [MyController])
     * ```
     *
     * ::: tip
     * If the MyController class isn't decorated, the class will be ignored.
     * :::
     *
     * @param {string} endpoint
     * @param {any[]} controllers
     * @returns {ServerLoader}
     */
    addControllers(endpoint, controllers) {
        this.settings.mount[endpoint] = (this.settings.mount[endpoint] || []).concat(controllers);
    }
    runLifecycle() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            utils_1.setLoggerLevel(this.injector);
            const routes = yield utils_1.importProviders(this.injector);
            yield this.loadInjector();
            yield this.createContext();
            yield this.loadRoutes(routes);
            yield this.logRoutes();
        });
    }
    loadInjector() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { injector, logger } = this;
            yield this.callHook("$beforeInit");
            yield this.callHook("$onInit");
            logger.info("Build providers");
            yield utils_1.loadInjector(injector, utils_1.createContainer(core_1.constructorOf(this.rootModule)));
            logger.debug("Settings and injector loaded");
            yield this.callHook("$afterInit");
        });
    }
    listen() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { logger, startedAt } = this;
            yield this.callHook("$beforeListen");
            yield this.listenServers();
            yield this.callHook("$afterListen");
            yield this.ready();
            logger.info(`Started in ${new Date().getTime() - startedAt.getTime()} ms`);
        });
    }
    ready() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield this.callHook("$onReady");
            yield this.injector.emit("$onServerReady");
        });
    }
    callHook(key, ...args) {
        return utils_1.callHook(this.injector, this.rootModule, key, ...args);
    }
    bootstrap(module, settings = {}) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            this.createInjector(module, settings);
            this.createRootModule(module);
            yield this.runLifecycle();
            return this;
        });
    }
    listenServers() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            yield Promise.all([utils_1.listenHttpServer(this.injector), utils_1.listenHttpsServer(this.injector)]);
        });
    }
    logRoutes() {
        const { logger, platform } = this;
        if (!this.settings.logger.disableRoutesSummary) {
            logger.info("Routes mounted :");
            logger.info(utils_1.printRoutes(platform.getRoutes()));
        }
    }
    createContext() {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const middleware = new ContextMiddleware_1.ContextMiddleware(this.injector);
            return this.app.use(middleware.use.bind(middleware));
        });
    }
    loadRoutes(routes) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
            const { logger, platform } = this;
            logger.info("Load routes");
            yield this.callHook("$beforeRoutesInit"); // deprecated
            platform.addRoutes(routes);
            yield this.callHook("$onRoutesInit");
            yield this.loadStatics();
            yield this.callHook("$afterRoutesInit");
        });
    }
    createInjector(module, settings) {
        this._injector = utils_1.createInjector(utils_1.getConfiguration(module, settings));
        utils_1.createPlatformApplication(this.injector);
    }
    createRootModule(module) {
        this._rootModule = this.injector.invoke(module, undefined, {
            imports: this.settings.imports
        });
        this.injector.delete(core_1.constructorOf(this._rootModule));
        this.injector.delete(core_1.classOf(this._rootModule));
    }
}
exports.PlatformBuilder = PlatformBuilder;
//# sourceMappingURL=PlatformBuilder.js.map