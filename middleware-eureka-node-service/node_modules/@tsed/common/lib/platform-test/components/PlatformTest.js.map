{"version":3,"file":"PlatformTest.js","sourceRoot":"","sources":["../../../src/platform-test/components/PlatformTest.ts"],"names":[],"mappings":"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","sourcesContent":["import {Env, Type} from \"@tsed/core\";\nimport {InjectorService, LocalsContainer, OnInit, TokenProvider} from \"@tsed/di\";\nimport {createInjector, loadInjector, PlatformBuilder} from \"../../platform-builder\";\nimport {PlatformApplication} from \"../../platform/services/PlatformApplication\";\n\nexport interface ITestInvokeOptions {\n  token?: TokenProvider;\n  use: any;\n}\n\nexport class PlatformTest {\n  public static platformBuilder: Type<PlatformBuilder>;\n  protected static _injector: InjectorService | null = null;\n\n  static get injector(): InjectorService {\n    if (this._injector) {\n      return this._injector!;\n    }\n\n    /* istanbul ignore next */\n    throw new Error(\n      \"PlatformTest.injector is not initialized. Use PlatformTest.create(): Promise before PlatformTest.invoke() or PlatformTest.injector.\\n\" +\n        \"Example:\\n\" +\n        \"before(async () => {\\n\" +\n        \"   await PlatformTest.create()\\n\" +\n        \"   await PlatformTest.invoke(MyService, [])\\n\" +\n        \"})\"\n    );\n  }\n\n  static async create(options: Partial<TsED.Configuration> = {}) {\n    PlatformTest._injector = PlatformTest.createInjector(options);\n\n    await loadInjector(PlatformTest._injector);\n  }\n\n  /**\n   * Create a new injector with the right default services\n   */\n  static createInjector(options: any = {}): InjectorService {\n    const injector = createInjector(options);\n\n    injector.settings.env = Env.TEST;\n\n    return injector;\n  }\n\n  /**\n   * Load the server silently without listening port and configure it on test profile.\n   * @decorator\n   * @param mod\n   * @param options\n   * @returns {Promise<void>}\n   */\n  static bootstrap(mod: Type<any>, options: Partial<TsED.Configuration> = {}): () => Promise<void> {\n    return async function before(): Promise<void> {\n      // @ts-ignore\n      const instance = await PlatformBuilder.build(PlatformTest.platformBuilder).bootstrap(mod, {\n        logger: {\n          level: \"off\"\n        },\n        ...options\n      });\n\n      await instance.callHook(\"$beforeListen\");\n      await instance.callHook(\"$afterListen\");\n      await instance.ready();\n\n      // used by inject method\n      PlatformTest._injector = instance.injector;\n    };\n  }\n\n  /**\n   * Resets the test injector of the test context, so it won't pollute your next test. Call this in your `tearDown` logic.\n   */\n  static async reset() {\n    if (PlatformTest._injector) {\n      await PlatformTest._injector.destroy();\n      PlatformTest._injector = null;\n    }\n  }\n\n  /**\n   * It injects services into the test function where you can alter, spy on, and manipulate them.\n   *\n   * The inject function has two parameters\n   *\n   * * an array of Service dependency injection tokens,\n   * * a test function whose parameters correspond exactly to each item in the injection token array.\n   *\n   * @param targets\n   * @param func\n   */\n  static inject<T>(targets: any[], func: (...args: any[]) => Promise<T> | T): () => Promise<T> {\n    return async (): Promise<T> => {\n      if (!PlatformTest._injector) {\n        await PlatformTest.create();\n      }\n\n      const injector: InjectorService = PlatformTest.injector;\n      const deps = [];\n\n      for (const target of targets) {\n        deps.push(injector.has(target) ? injector.get(target) : await injector.invoke(target));\n      }\n\n      return await func(...deps);\n    };\n  }\n\n  static invoke<T = any>(target: TokenProvider, providers: ITestInvokeOptions[]): T | Promise<T> {\n    const locals = new LocalsContainer();\n    providers.forEach(p => {\n      locals.set(p.token, p.use);\n    });\n\n    const instance: OnInit = PlatformTest.injector.invoke(target, locals, {rebuild: true});\n\n    if (instance && instance.$onInit) {\n      // await instance.$onInit();\n      const result = instance.$onInit();\n      if (result instanceof Promise) {\n        return result.then(() => instance as any);\n      }\n    }\n\n    return instance as any;\n  }\n\n  /**\n   * Return the raw application (express or koa).\n   * Use this callback with SuperTest.\n   *\n   * ```typescript\n   * let request: SuperTest.SuperTest<SuperTest.Test>;\n   * beforeEach(PlatformTest.bootstrap(Server, {\n   *   mount: {\n   *     \"/rest\": [ProductsController]\n   *   }\n   * }));\n   * beforeEach(() => {\n   *   request = SuperTest(PlatformTest.callback());\n   * });\n   * ```\n   */\n  static callback() {\n    return PlatformTest.injector.get<PlatformApplication>(PlatformApplication)?.callback();\n  }\n}\n"]}