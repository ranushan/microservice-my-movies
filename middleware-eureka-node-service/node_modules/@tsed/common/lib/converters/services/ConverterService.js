"use strict";
var ConverterService_1;
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const core_1 = require("@tsed/core");
const di_1 = require("@tsed/di");
const PropertyRegistry_1 = require("../../jsonschema/registries/PropertyRegistry");
const getJsonSchema_1 = require("../../jsonschema/utils/getJsonSchema");
const components_1 = require("../components");
const index_1 = require("../constants/index");
const RequiredPropertyError_1 = require("../errors/RequiredPropertyError");
const UnknownPropertyError_1 = require("../errors/UnknownPropertyError");
let ConverterService = ConverterService_1 = class ConverterService {
    constructor(injectorService, configuration) {
        this.injectorService = injectorService;
        this.converterSettings = configuration.get("converter") || {};
        if (this.converterSettings.additionalProperties === undefined) {
            const validationModelStrict = configuration.get("validationModelStrict");
            this.converterSettings.additionalProperties = validationModelStrict || validationModelStrict === undefined ? "error" : "accept";
        }
    }
    /**
     * Return a JsonMetadata for a properties.
     * @param properties
     * @param propertyKey
     * @returns {undefined|V|string|any|T|IDBRequest}
     */
    static getPropertyMetadata(properties, propertyKey) {
        if (properties.has(propertyKey)) {
            return properties.get(propertyKey);
        }
        let property;
        properties.forEach(p => {
            if (p.name === propertyKey || p.propertyKey === propertyKey) {
                property = p;
            }
        });
        return property;
    }
    /**
     * Convert instance to plainObject.
     *
     * ### Options
     *
     * - `checkRequiredValue`: Disable the required check condition.
     *
     * @param obj
     * @param options
     */
    serialize(obj, options = {}) {
        if (core_1.isEmpty(obj)) {
            return obj;
        }
        const converter = this.getConverter(obj);
        const serializer = (o, opt) => this.serialize(o, Object.assign({}, options, opt));
        if (converter && converter.serialize) {
            // serialize from a custom JsonConverter
            return converter.serialize(obj, serializer);
        }
        if (typeof obj.serialize === "function") {
            // serialize from serialize method
            return obj.serialize(options, this);
        }
        if (typeof obj.toJSON === "function" && !obj.toJSON.$ignore) {
            // serialize from serialize method
            return obj.toJSON();
        }
        // Default converter
        if (!core_1.isPrimitiveOrPrimitiveClass(obj)) {
            return this.serializeClass(obj, options);
        }
        /* istanbul ignore next */
        return obj;
    }
    /**
     *
     * @param obj
     * @param {IConverterOptions} options
     * @returns {any}
     */
    serializeClass(obj, options = {}) {
        const { checkRequiredValue = true, withIgnoredProps } = options;
        const plainObject = {};
        const properties = PropertyRegistry_1.PropertyRegistry.getProperties(options.type || obj, { withIgnoredProps });
        const keys = properties.size ? Array.from(properties.keys()) : Object.keys(obj);
        keys.forEach(propertyKey => {
            if (typeof obj[propertyKey] !== "function") {
                let propertyMetadata = ConverterService_1.getPropertyMetadata(properties, propertyKey);
                let propertyValue = obj[propertyKey];
                propertyMetadata = propertyMetadata || {};
                propertyValue = this.serialize(propertyValue, {
                    checkRequiredValue,
                    withIgnoredProps,
                    type: propertyMetadata.type
                });
                if (typeof propertyMetadata.onSerialize === "function") {
                    propertyValue = propertyMetadata.onSerialize(propertyValue);
                }
                plainObject[propertyMetadata.name || propertyKey] = propertyValue;
            }
        });
        return plainObject;
    }
    /**
     * Convert a plainObject to targetType.
     *
     * ### Options
     *
     * - `ignoreCallback`: callback called for each object which will be deserialized. The callback can return a boolean to avoid the default converter behavior.
     * - `checkRequiredValue`: Disable the required check condition.
     *
     * @param obj Object source that will be deserialized
     * @param targetType Pattern of the object deserialized
     * @param baseType
     * @param options
     * @returns {any}
     */
    deserialize(obj, targetType, baseType, options = {}) {
        const { ignoreCallback, checkRequiredValue = true } = options;
        if (ignoreCallback && ignoreCallback(obj, targetType, baseType)) {
            return obj;
        }
        if (targetType !== Boolean && (core_1.isEmpty(obj) || core_1.isEmpty(targetType) || targetType === Object)) {
            return obj;
        }
        const converter = this.getConverter(targetType);
        const deserializer = (o, targetType, baseType) => this.deserialize(o, targetType, baseType, options);
        if (converter) {
            // deserialize from a custom JsonConverter
            return converter.deserialize(obj, targetType, baseType, deserializer);
        }
        /* istanbul ignore next */
        if (core_1.isArrayOrArrayClass(obj)) {
            const converter = this.getConverter(Array);
            return converter.deserialize(obj, Array, baseType, deserializer);
        }
        if (targetType.prototype && typeof targetType.prototype.deserialize === "function") {
            // deserialize from method
            const instance = new targetType();
            instance.deserialize(obj);
            return instance;
        }
        // Default converter
        const instance = new targetType();
        const properties = PropertyRegistry_1.PropertyRegistry.getProperties(targetType);
        Object.keys(obj).forEach((propertyName) => {
            const propertyMetadata = ConverterService_1.getPropertyMetadata(properties, propertyName);
            return this.convertProperty(obj, instance, propertyName, propertyMetadata, options);
        });
        // Required validation
        if (checkRequiredValue) {
            // TODO v6 REMOVE REQUIRED check
            this.checkRequiredValue(instance, properties);
        }
        return instance;
    }
    /**
     *
     * @param targetType
     * @returns {any}
     */
    getConverter(targetType) {
        if (core_1.Metadata.has(index_1.CONVERTER, targetType)) {
            const converter = core_1.Metadata.get(index_1.CONVERTER, targetType);
            if (converter) {
                return this.injectorService.get(converter);
            }
        }
    }
    /**
     *
     * @param {Type<any>} target
     * @returns {"error" | "accept" | "ignore"}
     */
    getAdditionalPropertiesLevel(target) {
        if (target !== Object) {
            const { additionalProperties } = getJsonSchema_1.getJsonSchema(target);
            if (additionalProperties !== undefined) {
                return !additionalProperties ? "error" : "accept";
            }
            return this.converterSettings.additionalProperties;
        }
        return "accept";
    }
    /**
     *
     * @param obj
     * @param instance
     * @param {string} propertyName
     * @param {PropertyMetadata} propertyMetadata
     * @param options
     */
    convertProperty(obj, instance, propertyName, propertyMetadata, options) {
        if (this.skipAdditionalProperty(instance, propertyName, propertyMetadata, options)) {
            return;
        }
        propertyMetadata = propertyMetadata || {};
        let propertyValue = obj[propertyMetadata.name] || obj[propertyName];
        const propertyKey = propertyMetadata.propertyKey || propertyName;
        if (typeof instance[propertyKey] !== "function") {
            if (typeof propertyMetadata.onDeserialize === "function") {
                propertyValue = propertyMetadata.onDeserialize(propertyValue);
            }
            instance[propertyKey] = this.deserialize(propertyValue, propertyMetadata.isCollection ? propertyMetadata.collectionType : propertyMetadata.type, propertyMetadata.type, options);
        }
    }
    /**
     * @deprecated
     * @param instance
     * @param {Map<string | symbol, PropertyMetadata>} properties
     */
    checkRequiredValue(instance, properties) {
        properties.forEach((propertyMetadata) => {
            const value = instance[propertyMetadata.propertyKey];
            if (propertyMetadata.isRequired(value)) {
                throw new RequiredPropertyError_1.RequiredPropertyError(core_1.getClass(instance), propertyMetadata.propertyKey, value);
            }
        });
    }
    /**
     *
     * @param instance
     * @param {string} propertyKey
     * @param {PropertyMetadata | undefined} propertyMetadata
     * @param options
     */
    skipAdditionalProperty(instance, propertyKey, propertyMetadata, options) {
        if (propertyMetadata !== undefined) {
            return false;
        }
        const additionalPropertiesLevel = options.additionalProperties || this.getAdditionalPropertiesLevel(core_1.getClass(instance));
        switch (additionalPropertiesLevel) {
            case "error":
                throw new UnknownPropertyError_1.UnknownPropertyError(core_1.getClass(instance), propertyKey);
            case "ignore":
                return true;
            case "accept":
                return false;
        }
    }
};
ConverterService = ConverterService_1 = tslib_1.__decorate([
    di_1.Injectable({
        imports: [components_1.ArrayConverter, components_1.DateConverter, components_1.MapConverter, components_1.PrimitiveConverter, components_1.SetConverter, components_1.SymbolConverter]
    }),
    tslib_1.__param(1, di_1.Configuration()),
    tslib_1.__metadata("design:paramtypes", [di_1.InjectorService, Object])
], ConverterService);
exports.ConverterService = ConverterService;
//# sourceMappingURL=ConverterService.js.map